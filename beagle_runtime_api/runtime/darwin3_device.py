import struct,os, glob, random, time, re, json, logging 
import numpy as np
import logging,os,json,glob,re,struct,time
from io import StringIO,BytesIO
from pathlib import Path

from .tcp_transmitter import Transmitter

from .darwin_flit.decode import decode
from .darwin_flit.encode import encode
from .darwin_flit.result import SpikeResult
from .darwin_flit.constant import PKG_WRITE,PKG_WRITE,PKG_SPIKE,PKG_CMD,WEST,EAST
from .darwin_flit.parse_config import parse_compiler_config

from x_secretary.utils.time import measure_time

class darwin3_device(object):
    """
    用于和Darwin3开发板进行通信的类
    """
    CHIP_RESET = 10
    SET_FREQUENCY = 11
    NORMAL_FLIT = 0x8000
    
    def __init__(
        self, protocol="TCP", ip=['172.31.111.35'], port=[6000, 6001], step_size=100000, app_path="../", log_debug=False, spk_print=False,
    ):
        """
        
        Args:
            protocol (str):   与 Darwin3 开发板通信使用的协议, 默认 TCP, 可选 LOCAL, 暂不支持其它
            ip (list(str)):   Darwin3 板卡设备 ip 序列, 单芯片开发板最多支持两个 ip
                              默认使用 ip[0] 进行上下位机通信 (暂不支持 ip[1] 的连接)
                              (因为有两张网卡, 以太网接口和type-C接口均可使用)
            port (list(int)): 与 Darwin3 开发板通信使用的端口, 默认为 6000 和 6001
                              其中 port[0] 为和 Darwin3 west 端 DMA 进行通信的端口
                              port[0] 为和 Darwin3 east 端 DMA 进行通信的端口
                              最多支持 4 个端口, 对面 DMA 的四个通道 (目前仅支持 2 个)
            step_size (int):  每个时间步维持的 FPGA 时钟周期数, 对应时长为 10ns * step_size * 2
                              (汇编工具介绍与上位机通信流程中有换算关系，对应run_input.dwnc中最开始的配置)
            app_path (str):   模型文件的存储目录, 存储目录格式如下所示
            .
            ├── apps (name user-defined)
            │   ├── config_files
            │   │   ├── spikes.dwnc (generated by script, users don't need to care)
            │   │   ├── 0-1-config.dwnc
            │   │   ├── 0-1-ax.txt
            │   │   ├── 0-1-de.txt
            │   │   ├── 0-2-config.dwnc
            │   │   ├── 0-2-ax.txt
            │   │   ├── 0-2-de.txt
            │   │   ├── 1-1-config.dwnc
            │   │   ├── 1-1-ax.txt
            │   │   ├── 1-1-de.txt
            │   │   ├── input_neuron.json
            │   │   ├── pop_h_1.json
            │   │   ├── pop_h_2.json
            │   │   ├── output_neuron_xxx.json
            │   │   └── ...
            │   ├── deploy_files (generated by script, users don't need to care)
            │   │   ├── deploy_input.dwnc
            │   │   ├── deploy_flitin.txt
            │   │   └── deploy_flitin.bin
            │   ├── input_files (generated by script, users don't need to care)
            │   │   ├── run_input.dwnc
            │   │   ├── run_flitin.txt
            │   │   └── run_flitin.bin
            │   ├── debug_files (generated by script, users don't need to care)
            │   │   ├── get_neuron_state_flitin.bin
            │   │   ├── get_neuron_state_flitin.txt
            │   │   └── ...
            │   ├── output_files (generated by script, results)
            │   │   ├── recv_run_flit.txt
            │   │   └── recv_run_flit.bin
            │   └── model (other app flies, name user-defined)
            ├── darwin3_runtime_api
            │   ├── darwin3_device.py
            │   └── [your scripts using darwin3_device class](optional)
            ├── script
            │   ├── darwin3_runtime_server.py
            │   ├── restart_dma.sh
            │   └── init.sh
            ├── README.md
            └── setup.py
        """
        if log_debug:
            logging.basicConfig(level=logging.DEBUG,  # 设置最低日志级别为 DEBUG
                    format='%(asctime)s - %(levelname)s - %(message)s',  # 日志格式
                    filename='app.log',  # 将日志输出到文件 app.log
                    filemode='w')  # 'a'表示追加模式，'w'表示覆盖模式
        
        self.log_debug = log_debug
        # protocol (str): 和 Darwin3 的连接方式
        self.protocol = protocol
        # ip (str): 和 Darwin3 进行 TCP 连接的 IP 地址
        # port (list(int)): 和 Darwin3 进行 TCP 连接的端口号序列
        if self.protocol == "LOCAL":
            self.ip = "127.0.0.1"
        else:
            self.ip = ip[0]
        self.port = port

        # step_size (int): 时间步长度
        self.hardware_step_size = step_size

        # app_path (str): 存储应用的目录
        self.app_path=Path(app_path)


        # config_path (str): 配置文件目录
        self.config_path = self.app_path / "config_files"

        self._cache_path=self.app_path / 'beagle_cache'
        Path.mkdir(self._cache_path,exist_ok=True,parents=True)
        # deploy_path (str): 部署文件目录 (.txt && .bin)
        self.deploy_path = self._cache_path
        # debug_path (str): 查询所有神经元状态信息存储目录 (仅用于调试)
        self.debug_path = self._cache_path

        # input_neuron (list): 读取 input_neuron.json 文件, 存储为list
        with open(self.config_path / "input_neuron.json", "r") as f:
            self.input_neuron = json.load(f)

        # config_neuron_list (list): 需要进行配置的神经元列表
        self.config_file_format = "*-*-config.dwnc"
        self.config_neuron_list = []
        search_paths = Path.glob(self.config_path, self.config_file_format)

        self.isreset = {}
        self.vtreset = {}
        for search_path in search_paths:
            file = search_path.name
            _neuron_coord = re.findall(r"\d+", file)
            _neuron_coord = (int(_neuron_coord[0]),int(_neuron_coord[1]))
            self.config_neuron_list.append(_neuron_coord)
            with open(self.config_path / file,'r') as f:
                l = f.readlines()
                index = len(l)-1
                flag2 = False
                flag1 = False
                while index>=0:
                    temp = l[index].split()
                    if len(temp)>=6 and 'is' in temp[5]:
                        self.isreset[_neuron_coord] = l[index]
                        flag1 = True
                    elif len(temp)>=6 and 'vt' in temp[5]:
                        self.vtreset[_neuron_coord] = l[index]
                        flag2 = True
                    if flag1 and flag2:
                        break
                    index -= 1

        # deploy_from_east (bool): 判断是否需要从东边进行配置
        self.deploy_from_east = False
        self.clear_sate_had_started = False
        self.printc = spk_print
        self.deploy_config_had_started = False

        format = "output_neuron*.json"
        pattern = re.compile(r'output_neuron_(.*?)\.json')
        search_paths = Path.glob(self.config_path , format)
        self._output_neuron_info_jsons=[]
        for search_path in search_paths:
            file = search_path.name
            output_name = pattern.match(file).group(1)
            # self.output_neuron_info_jsons.append((output_name,json.load(f)))
            with open(self.config_path / file, "r") as f:
                _js=json.load(f)
                _new_json={}
                for __x,__id in _js.items():
                    _3_s=__x.split(',')
                    _new_json[(int(_3_s[0]),int(_3_s[1]),int(_3_s[2]))]=__id
                self._output_neuron_info_jsons.append((output_name,_new_json))

        if os.path.exists(self.config_path / "delay_record.json"):
            with open(self.config_path / "delay_record.json", "r") as f:
                self.delay_neuron = json.load(f)
        else:
            self.delay_neuron = {}
        
        return

    def enable_neurons(self, dwnc_file="enable"):
        """
        将 config_files 中所有需要使用的神经元使能
        Args:
            dwnc_file (str): 生成的配置文件名称
        Returns:
            None
        """
        raise NotImplementedError
        # 生成 dwnc 文件
        with open(self.deploy_path / (dwnc_file + ".dwnc"), "w+") as fwest, \
        open(self.deploy_path / (dwnc_file + "_east.dwnc"), "w+") as feast:
            fwest.write('0 cmd 0xc0000001\n')
            feast.write('0 cmd 0xc0000001\n')
            for neuron in self.config_neuron_list:
                if int(neuron[0]) <= 15:
                    fwest.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
                else:
                    self.deploy_from_east = True
                    feast.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
            fwest.write('0 cmd 0xc0000000\n')
            feast.write('0 cmd 0xc0000000\n')
        if self.deploy_from_east == False:
            os.remove(self.deploy_path / (dwnc_file + "_east.dwnc"))
        
        # 生成 flit 文件
        self.__flit_gen__(
            type="deploy",
            input_file=dwnc_file+".dwnc",
            output_file=dwnc_file+"_flitin",
        )
        if self.deploy_from_east:
            self.__flit_gen_east__(
                type="deploy",
            input_file=dwnc_file+"_east.dwnc",
            output_file=dwnc_file+"_flitin_east",
            )
            
        # 发送 flit 包到 Darwin3 板卡
        self.__transmit_flit__(port=self.port[0], data_type=self.NORMAL_FLIT, fbin=self.deploy_path / (dwnc_file + "_flitin.bin"))
        if self.deploy_from_east:
            self.__transmit_flit__(port=self.port[1], data_type=self.NORMAL_FLIT, fbin=self.deploy_path / (dwnc_file + "_flitin_east.bin"))
        return
    
    def disable_neurons(self, dwnc_file="disable"):
        """
        将 config_files 中所有需要使用的神经元取消使能
        Args:
            dwnc_file (str): 生成的配置文件名称
        Returns:
            None
        """
        raise NotImplementedError
        # 生成 dwnc 文件
        with open(self.deploy_path / (dwnc_file + ".dwnc"), "w+") as fwest, \
        open(self.deploy_path / (dwnc_file + "_east.dwnc"), "w+") as feast:
            fwest.write('0 cmd 0xc0000001\n')
            feast.write('0 cmd 0xc0000001\n')
            for neuron in self.config_neuron_list:
                if int(neuron[0]) <= 15:
                    fwest.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
                else:
                    self.deploy_from_east = True
                    feast.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
            fwest.write('0 cmd 0xc0000000\n')
            feast.write('0 cmd 0xc0000000\n')
        if self.deploy_from_east == False:
            os.remove(self.deploy_path + dwnc_file + "_east.dwnc")
            
        # 生成 flit 文件
        self.__flit_gen__(
            type="deploy",
            input_file=dwnc_file  + ".dwnc",
            output_file=dwnc_file + "_flitin",
        )
        if self.deploy_from_east:
            self.__flit_gen_east__(
                type="deploy",
            input_file=dwnc_file+"_east.dwnc",
            output_file=dwnc_file+"_flitin_east",
            )
            
        # 发送 flit 包到 Darwin3 板卡
        self.__transmit_flit__(port=self.port[0], data_type=self.NORMAL_FLIT, fbin=self.deploy_path / (dwnc_file+"_flitin.bin"))
        if self.deploy_from_east:
            self.__transmit_flit__(port=self.port[1], data_type=self.NORMAL_FLIT, fbin=self.deploy_path / (dwnc_file+"_flitin_east.bin"))
        return
        
    def clear_neurons_states(self, ISC=False, LSC=False, clear=True, dwnc_file="clear_states"):
        """
        清理 darwin3 芯片内部神经拟态核心的状态量
        Args:
            ISC   (bool): inference status clear,
                          推理状态中电流清零, 阈值和振荡电位复位, 1 有效
                          相关配置寄存器: dedr_vth_keep, dedr_vth_gset, 
                          global_vth, dedr_res_keep, global_res
            LSC   (bool): learn status clear, 学习状态清零, 1 有效
            clear (bool): 权重和清零, 膜电位复位, 1 有效
                          相关配置寄存器:vt_rest
                          
            dwnc_file (str): 生成的配置文件名称
        Returns:
            None
        """
        # 根据需要重置的内容生成指令
        if not self.clear_sate_had_started:
            clear_type = int(''.join(str(int(b)) for b in [ISC, LSC, clear]), 2)
            
            fwest=[(PKG_CMD,0,1)]
            feast=[(PKG_CMD,0,1)]

            for neuron in self.config_neuron_list:
                if int(neuron[0]) <= 15:
                    fwest.append((PKG_WRITE,neuron[0],neuron[1],0x04,clear_type))
                    # fwest.write(f'0 write {neuron[0]} {neuron[1]} 0x04 {clear_type}\n')
                    # if neuron in self.isreset:
                        # fwest.write(self.isreset[neuron])
                    # if neuron in self.vtreset:
                        # fwest.write(self.vtreset[neuron])
                else:
                    self.deploy_from_east = True
                    feast.append((PKG_WRITE,neuron[0],neuron[1],0x04,clear_type))
                    # feast.write(f'0 write {neuron[0]} {neuron[1]} 0x04 {clear_type}\n')
                    # if neuron in self.isreset:
                        # feast.write(self.isreset[neuron])
                    # if neuron in self.vtreset:
                        # feast.write(self.vtreset[neuron])
                for key,value in self.delay_neuron.items():
                    coord = eval(key)
                    if coord[0] <= 15:
                        fwest.append((PKG_WRITE,coord[0],coord[1],0x00800+value[0], value[1]))
                        fwest.append((PKG_WRITE,coord[0],coord[1],0x00800+value[2], value[3]))
                    else:
                        fwest.append((PKG_WRITE,coord[0],coord[1],0x00800+value[0], value[1]))
                        feast.append((PKG_WRITE,coord[0],coord[1],0x00800+value[2], value[3]))
                        # fwest.write(f'0 write {coord[0]} {coord[1]} {hex(0x00800+value[0])} {hex(value[1])}\n')
                        # fwest.write(f'0 write {coord[0]} {coord[1]} {hex(0x00800+value[2])} {hex(value[3])}\n')                       
            fwest.append((PKG_CMD,0,0))
            feast.append((PKG_CMD,0,0))

            self._cached_clear_state=encode(feast,WEST)
            self.clear_sate_had_started = True
        # send
        # Path.write_bytes(Path('tmp.bin'),bin_io_rslt)
        # input('save bin')
        self._transmit_flit(port=self.port[0], 
            data_type=self.NORMAL_FLIT,
            flit_bin=self._cached_clear_state,
            recv=False,
            recv_run_flit_file=None)
        return
    
    # new part
    def _gen_deploy_flitin(self):
        """
        *-*-config.dwnc => deploy_input.dwnc
        Args:
            deploy_input_dwnc_file (str): 生成的 dwnc 文件的名称
        Returns:
            None
        """
        # 打开东西向传输的文件
        west_dwnc_list=[]
        east_dwnc_list=[]

        deploy_from_east_flag = False
        # 清除神经元推理状态和权重和
        for neuron in self.config_neuron_list:
            if int(neuron[0]) <= 15:
                west_dwnc_list.append((PKG_WRITE,neuron[0],neuron[1],0x04,0x5))
            else:
                deploy_from_east_flag = True
                east_dwnc_list.append((PKG_WRITE,neuron[0],neuron[1],0x04,0x5))
        
        fw,fe=parse_compiler_config(self.config_path)
        west_dwnc_list.extend(fw)
        east_dwnc_list.extend(fe)

        # 加入开启/停止tik控制对 => 代表配置结束
        west_dwnc_list.append((PKG_CMD,0,1))
        west_dwnc_list.append((PKG_CMD,0,0))
        east_dwnc_list.append((PKG_CMD,0,1))
        east_dwnc_list.append((PKG_CMD,0,0))

        # 设置tick
        west_dwnc_list.append((PKG_CMD,0b100000,self.hardware_step_size))
        east_dwnc_list.append((PKG_CMD,0b100000,self.hardware_step_size))

        # 使能神经元，清除神经元权重和
        for neuron in self.config_neuron_list:
            if int(neuron[0]) <= 15:
                west_dwnc_list.append((PKG_WRITE,neuron[0],neuron[1],0x15,0x1))
                west_dwnc_list.append((PKG_WRITE,neuron[0],neuron[1],0x04,0x1))
            else:
                east_dwnc_list.append((PKG_WRITE,neuron[0],neuron[1],0x15,0x1))
                east_dwnc_list.append((PKG_WRITE,neuron[0],neuron[1],0x04,0x1))
    
        return west_dwnc_list,east_dwnc_list,deploy_from_east_flag

    def reset(self):
        """
        复位硬件接口相关逻辑和硬件系统(darwin3 芯片, DMA 等)
        Args: 
            None
        Returns:
            None
        """
        self._transmit_flit(port=self.port[0], data_type=darwin3_device.CHIP_RESET)
        print("Please check the information on the Darwin3 development board ")
        print("to determine if the configuration was successful.")
        return
    
    def darwin3_init(self, freq=333):
        """
        按照指定频率配置 darwin3 芯片。
        Args:
            freq (int): 兼容参数，无实际作用
        Returns:
            None
        """
        self._transmit_flit(port=self.port[0], data_type=darwin3_device.SET_FREQUENCY)
        print("Please check the information on the Darwin3 development board ")
        print("to determine if the configuration was successful.")
        return
    
    def _transmit_flit(self, port, data_type, flit_bin:bytearray=b'', recv=False, recv_run_flit_file : Path=None) -> BytesIO:
        """
        发包到darwin3, recv=True时接收darwin3返回来的包
        Args:
            port (list(int)): TCP 连接端口列表
            data_type (int): 发送包的格式
            freq (int): 设置的时钟频率 (仅当 data_type==SET_FREQUENCY 时有效)
            fbin (str): 发送的包内容 (仅当 data_type==NORMAL_FLIT 时有效)
            recv (bool): 是否接受 Darwin3 的返回包
            recv_run_flit_file (str): 保存返回包的名称
            debug (bool): 调试标记
        Returns:
            None
        """
        trans = Transmitter()
        trans.connect_lwip((self.ip, port))
        # print("===<1>=== tcp connect succeed")
        # start_time = time.time_ns()
        match data_type:
            case darwin3_device.CHIP_RESET:
                send_bytes = bytearray()
                send_bytes += struct.pack('II', 0x0000,data_type)
                trans.socket_inst.sendall(send_bytes)
                print("===<2>=== reset succeed")
            case darwin3_device.SET_FREQUENCY:
                send_bytes = bytearray()
                send_bytes += struct.pack('II', 333,data_type)
                trans.socket_inst.sendall(send_bytes)
                print("===<2>=== set frequency succeed")
            case _ :
                trans.send_flit_bin_without_file(flit_bin, data_type)
                # print("===<2>=== send succeed")
        # end_time = time.time_ns()
        # print('===<3>=== tcp sent elapsed : %.3f ms' % ((end_time - start_time)/1000000))

        fout = BytesIO()
        if recv:
            data_len=0
            while True:
                request = trans.socket_inst.recv(10240)
                if not request: break # 无数据时退出
                data_len += len(request)
                fout.write(request)
            if data_len % 4 !=0:
                print(f"received data is not intact (with {len})!")
        if recv_run_flit_file is not None:
            recv_run_flit_file.write_bytes(fout.getvalue())

        trans.close()
        return fout

    def _gen_spike_input_dwnc(
        self,
        neuron_spike_list: list,
    ) -> list:
        """
        input_neuron.json && length of spike_neurons (list) => spikes.dwnc
        跟据spikes.dwnc以及config文件中提到的神经元，生成对应的run_input.dwnc文件
        Args:
            neuron_spike_list (list): 输入的神经元脉冲序列
        Returns:
            dwnc list
        """
        dwnc_list=[(PKG_CMD,0,1)] # open time step
        for _i in range(0, len(neuron_spike_list)):
            cur_spike_neuron_list = neuron_spike_list[_i]
            for spike_neuron in cur_spike_neuron_list:
                neuron_info = self.input_neuron[str(spike_neuron)]
                if len(neuron_info) > 0:
                    neuron_type = neuron_info[0]
                    targets_list = neuron_info[-1]
                    if neuron_type == 0:
                        neu_idx = neuron_info[1]
                    elif neuron_type == 1:
                        neu_idx = 0x0
                    for target in targets_list:
                        dwnc_list.append((PKG_SPIKE,target[0],target[1],neu_idx,target[2]))
            dwnc_list.append((PKG_CMD,0b011000,0)) # step 1

        dwnc_list.append((PKG_CMD,0,0)) # turn off

        return dwnc_list

    def _excute_dwnc_command(self,dwnc_list,direction,saving_name='',recv=True,saving_recv=False) -> list:
        bin_io_rslt=encode(dwnc_list,direction)
        # send
        # Path.write_bytes(Path('tmp.bin'),bin_io_rslt)
        # input('save bin')
        rslt = self._transmit_flit(port=self.port[0], 
                            data_type=self.NORMAL_FLIT,
                            flit_bin=bin_io_rslt,
                            recv=recv,
                            recv_run_flit_file=None if not saving_recv else self._cache_path / f"recv_{saving_name}.txt")
        rslt = decode(rslt)
        return rslt

    def deploy_config(self):
        """
        在部署芯片上部署并使能相关核心, 同时清除神经元的相关状态
        Args:
            None
        Returns:
            None
        """
        dwnc_west,dwnc_east,east_flag=self._gen_deploy_flitin()
        self._excute_dwnc_command(dwnc_west,WEST,'deploy',recv=False)
        if east_flag:
            self._excute_dwnc_command(dwnc_east,EAST,'deploy',recv=False)

    def run_darwin3_withoutfile(self,spike_neurons):
        '''
        obselete api
        '''
        return self.run_darwin3_with_spikes(spike_neurons)

    def run_darwin3_withfile(self,spike_neurons):
        '''
        obselete api
        '''
        return self.run_darwin3_with_spikes(spike_neurons)

    def run_darwin3_with_spikes(self, spike_list: list,saving_input=False,saving_recv=False,print_log=False):
        """
        接收应用给的 spike_list 作为输入，运行 len(spike_list) 个时间步
        Args:
            spike_list (list): sequence, 本次应用输入给硬件的脉冲数据, 
                                  序列长度与时间步数量一致，没有脉冲的时间步给空值

            [
                [0,1,2], # neuron 0,1,2 fired at tick=0
                [0,1], # neuron 0,1 fired at tick=1
            ]
        Returns:
            result (list): 本次运行结束时硬件返回给应用的脉冲
        """
        # 生成spike的dwnc
        dwnc_list=self._gen_spike_input_dwnc(spike_list)
        if saving_input:
            (self._cache_path / 'run_input_dwnc.txt').write_text('\n'.join(dwnc_list))

        rslt=self._excute_dwnc_command(
            dwnc_list,
            WEST,
            'run_flitin',
            True,
            saving_recv)

        return SpikeResult.parse_spike(self._output_neuron_info_jsons,rslt,len(spike_list))

    def dump_memory(self,dump_request:list[tuple],log=False,saving_intermediate_dir: Path | None =None) -> tuple[list]:
        '''
        dump the memory of the specific neuromorphic core.
        ---
        @dump_request: 
        
            list of tuple:(

                nc_position: nc core coordinate, (x,y)

                length : words to be read, int

                offset : words offset, int

                inverse: read in reverse order, bool

            )

        @log: log to console

        @saving_dwnc_path: saving intermediate files
        '''
        raise NotImplementedError
        # construct dwnc list
        east_cmds=['0 cmd 0xc0000001\n']
        west_cmds=['0 cmd 0xc0000001\n']

        # x,y=nc_position
        for (_x,_y), _length, _offset, _inverse in dump_request:
            if _inverse:
                _addr_iter=range(_offset,_offset-_length,-1)
            else:
                _addr_iter=range(_offset,_offset+_length)

            for _2_addr in _addr_iter:
                cmd = f"0 read {_x} {_y} {hex(_2_addr)} 1\n"
                if _x>=15:
                    east_cmds.append(cmd)
                else:
                    west_cmds.append(cmd)

        east_cmds.append('0 cmd 0xc0000000\n')
        west_cmds.append('0 cmd 0xc0000000\n')
        
        rslt_west=None
        rslt_east=None
        if len(east_cmds)>2:
            with open('get_nc_denrites_east.dwnc','w') as f:
                f.writelines(east_cmds)
            self.__flit_gen_east__(type="debug", input_file='get_nc_denrites_east.dwnc', output_file='get_nc_denrites_east_flitin')
            self.__transmit_flit__(port=self.port[1], data_type=0x8000, 
                                   fbin=self.debug_path+'get_nc_denrites_east_flitin.bin', 
                                   recv=True, recv_run_flit_file="get_nc_denrites_east_recv",
                                   debug=True)
            rslt_east=parse_flit(recv_run_flit_file='get_nc_denrites_east_recv', log=log)

        if len(west_cmds)>2:
            if saving_intermediate_dir is not None:
                with open(saving_intermediate_dir/'get_nc_dendrites_west.dwnc','w') as f:
                    f.writelines(west_cmds)

            rslt_west= self._excute_dwnc_command(
                west_cmds,
                saving_intermediate_dir,
                'get_nc_dendrites_west_filtin',
                True if saving_intermediate_dir is not None else False,
                True if saving_intermediate_dir is not None else False,
                parser_log=log)
            
        return rslt_east,rslt_west
    
    def get_neuron_inference_status(self, nc_position:tuple,length:int,offset=0,log=False,saving_path: Path | None=None) -> tuple[list]:
        """
        获取推理存储器内容
        ---
        Args:
            nc_position: 神经元位置
            length: 读取的字数
            offset (int): 用户指定的地址偏移
            log: 是否输出到控制台
            saving_path: saved path of intermediate results (dwnc, flit in, flit out, etc.)
        Returns: 
            rslt_east,rslt_west
        """
        return NotImplementedError
        return self.dump_memory([(nc_position,length,0x0FFFF-offset,True)],log,saving_path)
    
    def get_dendrites_memory(self, nc_position:tuple,length:int,offset=0,log=False,saving_path: Path | None=None) -> tuple[list]:
        """
        获取树突存储器内容
        ---
        Args:
            nc_position: 神经元位置
            length: 读取的字数
            offset (int): 用户指定的地址偏移
            log: 是否输出到控制台
            saving_path: saved path of intermediate results (dwnc, flit in, flit out, etc.)
        Returns: 
            rslt_east,rslt_west
        """
        raise NotImplementedError
        return self.dump_memory([(nc_position,length,0x10000+offset,False)],log,saving_path)
    
    def get_learn_memory(self, nc_position:tuple,length:int,offset=0, log=False,saving_path: Path | None=None) -> tuple[list]:
        """
        获取学习状态存储器内容
        ---
        Args:
            nc_position: 神经元位置
            length: 读取的字数
            offset (int): 用户指定的地址偏移
            log: 是否输出到控制台
            saving_path: saved path of intermediate results (dwnc, flit in, flit out, etc.)
        Returns: 
            rslt_east,rslt_west
        """
        raise NotImplementedError
        return self.dump_memory([(nc_position,length,0x1DFFF-offset,True)],log,saving_path)