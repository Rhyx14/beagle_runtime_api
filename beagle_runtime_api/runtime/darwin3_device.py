import struct,os, glob, random, time, re, json, logging 
import numpy as np
import logging,os,json,glob,re,struct,time
from io import StringIO,BytesIO
from pathlib import Path
from enum import Enum

from .compiler_model import CompilerModel

from .tcp_transmitter import Transmitter

from .darwin_flit.decode import decode
from .darwin_flit.encode import encode
from .darwin_flit.result import SpikeResult
from .darwin_flit.constant import PKG_WRITE,PKG_WRITE,PKG_SPIKE,PKG_CMD,WEST,EAST
from .darwin_flit.command_list import CommandList
from x_secretary.utils.time import measure_time

try: 
    import torch
except ImportError as e:
    print('PyTorch is not installed, ensure that no torch-API is used!')

class FlitType():
    CHIP_RESET = 10
    SET_FREQUENCY = 11
    NORMAL_FLIT = 0x8000
    CLEAR_STATE = 0x8000
    RESET_SPIKING_INPUT= 0x8000

class darwin3_device(object):
    """
    用于和Darwin3开发板进行通信的类
    """

    def __init__(
        self, protocol="TCP", ip=['172.31.111.35'], port=[6000, 6001], step_size=100000, app_path="../", log_debug=False, spk_print=False,
    ):
        """
        
        Args:
            protocol (str):   与 Darwin3 开发板通信使用的协议, 默认 TCP, 可选 LOCAL, 暂不支持其它
            ip (list(str)):   Darwin3 板卡设备 ip 序列, 单芯片开发板最多支持两个 ip
                              默认使用 ip[0] 进行上下位机通信 (暂不支持 ip[1] 的连接)
                              (因为有两张网卡, 以太网接口和type-C接口均可使用)
            port (list(int)): 与 Darwin3 开发板通信使用的端口, 默认为 6000 和 6001
                              其中 port[0] 为和 Darwin3 west 端 DMA 进行通信的端口
                              port[0] 为和 Darwin3 east 端 DMA 进行通信的端口
                              最多支持 4 个端口, 对面 DMA 的四个通道 (目前仅支持 2 个)
            step_size (int):  每个时间步维持的 FPGA 时钟周期数, 对应时长为 10ns * step_size * 2
                              (汇编工具介绍与上位机通信流程中有换算关系，对应run_input.dwnc中最开始的配置)
            app_path (str):   模型文件的存储目录, 存储目录格式如下所示
            .
            ├── apps (name user-defined)
            │   ├── config_files
            │   │   ├── spikes.dwnc (generated by script, users don't need to care)
            │   │   ├── 0-1-config.dwnc
            │   │   ├── 0-1-ax.txt
            │   │   ├── 0-1-de.txt
            │   │   ├── 0-2-config.dwnc
            │   │   ├── 0-2-ax.txt
            │   │   ├── 0-2-de.txt
            │   │   ├── 1-1-config.dwnc
            │   │   ├── 1-1-ax.txt
            │   │   ├── 1-1-de.txt
            │   │   ├── input_neuron.json
            │   │   ├── pop_h_1.json
            │   │   ├── pop_h_2.json
            │   │   ├── output_neuron_xxx.json
            │   │   └── ...
            │   ├── deploy_files (generated by script, users don't need to care)
            │   │   ├── deploy_input.dwnc
            │   │   ├── deploy_flitin.txt
            │   │   └── deploy_flitin.bin
            │   ├── input_files (generated by script, users don't need to care)
            │   │   ├── run_input.dwnc
            │   │   ├── run_flitin.txt
            │   │   └── run_flitin.bin
            │   ├── debug_files (generated by script, users don't need to care)
            │   │   ├── get_neuron_state_flitin.bin
            │   │   ├── get_neuron_state_flitin.txt
            │   │   └── ...
            │   ├── output_files (generated by script, results)
            │   │   ├── recv_run_flit.txt
            │   │   └── recv_run_flit.bin
            │   └── model (other app flies, name user-defined)
            ├── darwin3_runtime_api
            │   ├── darwin3_device.py
            │   └── [your scripts using darwin3_device class](optional)
            ├── script
            │   ├── darwin3_runtime_server.py
            │   ├── restart_dma.sh
            │   └── init.sh
            ├── README.md
            └── setup.py
        """
        if log_debug:
            logging.basicConfig(level=logging.DEBUG,  # 设置最低日志级别为 DEBUG
                    format='%(asctime)s - %(levelname)s - %(message)s',  # 日志格式
                    filename='app.log',  # 将日志输出到文件 app.log
                    filemode='w')  # 'a'表示追加模式，'w'表示覆盖模式
        
        self.log_debug = log_debug
        # protocol (str): 和 Darwin3 的连接方式
        self.protocol = protocol
        # ip (str): 和 Darwin3 进行 TCP 连接的 IP 地址
        # port (list(int)): 和 Darwin3 进行 TCP 连接的端口号序列
        if self.protocol == "LOCAL":
            self.ip = "127.0.0.1"
        else:
            self.ip = ip[0]
        self.port = port

        # step_size (int): 时间步长度
        self.hardware_step_size = step_size

        # app_path (str): 存储应用的目录
        self.app_path=Path(app_path)

        # 输入输出目录，包括临时缓存
        self._cache_path=self.app_path / 'beagle_cache'
        Path.mkdir(self._cache_path,exist_ok=True,parents=True)

        self.clear_state_had_started = False

        self.model=CompilerModel(self.app_path / "config_files")
        return

    def enable_neurons(self, dwnc_file="enable"):
        """
        将 config_files 中所有需要使用的神经元使能
        Args:
            dwnc_file (str): 生成的配置文件名称
        Returns:
            None
        """
        raise NotImplementedError
        # 生成 dwnc 文件
        with open(self._cache_path / (dwnc_file + ".dwnc"), "w+") as fwest, \
        open(self._cache_path / (dwnc_file + "_east.dwnc"), "w+") as feast:
            fwest.write('0 cmd 0xc0000001\n')
            feast.write('0 cmd 0xc0000001\n')
            for neuron in self._config_neuron_coord_list:
                if int(neuron[0]) <= 15:
                    fwest.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
                else:
                    self.deploy_from_east = True
                    feast.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
            fwest.write('0 cmd 0xc0000000\n')
            feast.write('0 cmd 0xc0000000\n')
        if self.deploy_from_east == False:
            os.remove(self._cache_path / (dwnc_file + "_east.dwnc"))
        
        # 生成 flit 文件
        self.__flit_gen__(
            type="deploy",
            input_file=dwnc_file+".dwnc",
            output_file=dwnc_file+"_flitin",
        )
        if self.deploy_from_east:
            self.__flit_gen_east__(
                type="deploy",
            input_file=dwnc_file+"_east.dwnc",
            output_file=dwnc_file+"_flitin_east",
            )
            
        # 发送 flit 包到 Darwin3 板卡
        self.__transmit_flit__(port=self.port[0], data_type=self.NORMAL_FLIT, fbin=self._cache_path / (dwnc_file + "_flitin.bin"))
        if self.deploy_from_east:
            self.__transmit_flit__(port=self.port[1], data_type=self.NORMAL_FLIT, fbin=self._cache_path / (dwnc_file + "_flitin_east.bin"))
        return
    
    def disable_neurons(self, dwnc_file="disable"):
        """
        将 config_files 中所有需要使用的神经元取消使能
        Args:
            dwnc_file (str): 生成的配置文件名称
        Returns:
            None
        """
        raise NotImplementedError
        # 生成 dwnc 文件
        with open(self._cache_path / (dwnc_file + ".dwnc"), "w+") as fwest, \
        open(self._cache_path / (dwnc_file + "_east.dwnc"), "w+") as feast:
            fwest.write('0 cmd 0xc0000001\n')
            feast.write('0 cmd 0xc0000001\n')
            for neuron in self._config_neuron_coord_list:
                if int(neuron[0]) <= 15:
                    fwest.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
                else:
                    self.deploy_from_east = True
                    feast.write(f"0 write {neuron[0]} {neuron[1]} 0x15 0x1\n")
            fwest.write('0 cmd 0xc0000000\n')
            feast.write('0 cmd 0xc0000000\n')
        if self.deploy_from_east == False:
            os.remove(self._cache_path + dwnc_file + "_east.dwnc")
            
        # 生成 flit 文件
        self.__flit_gen__(
            type="deploy",
            input_file=dwnc_file  + ".dwnc",
            output_file=dwnc_file + "_flitin",
        )
        if self.deploy_from_east:
            self.__flit_gen_east__(
                type="deploy",
            input_file=dwnc_file+"_east.dwnc",
            output_file=dwnc_file+"_flitin_east",
            )
            
        # 发送 flit 包到 Darwin3 板卡
        self.__transmit_flit__(port=self.port[0], data_type=self.NORMAL_FLIT, fbin=self._cache_path / (dwnc_file+"_flitin.bin"))
        if self.deploy_from_east:
            self.__transmit_flit__(port=self.port[1], data_type=self.NORMAL_FLIT, fbin=self._cache_path / (dwnc_file+"_flitin_east.bin"))
        return

    def reset(self):
        """
        复位硬件接口相关逻辑和硬件系统(darwin3 芯片, DMA 等)
        Args: 
            None
        Returns:
            None
        """
        self._transmit_flit(port=self.port[0], data_type=darwin3_device.CHIP_RESET)
        print("Please check the information on the Darwin3 development board ")
        print("to determine if the configuration was successful.")
        return
    
    def darwin3_init(self, freq=333):
        """
        按照指定频率配置 darwin3 芯片。
        Args:
            freq (int): 兼容参数，无实际作用
        Returns:
            None
        """
        self._transmit_flit(port=self.port[0], data_type=darwin3_device.SET_FREQUENCY)
        print("Please check the information on the Darwin3 development board ")
        print("to determine if the configuration was successful.")
        return
    
    def _transmit_flit(self, port, data_type, flit_bin:bytearray=b'', recv=False, recv_run_flit_file : Path=None) -> BytesIO:
        """
        发包到darwin3, recv=True时接收darwin3返回来的包
        Args:
            port (list(int)): TCP 连接端口列表
            data_type (int): 发送包的格式
            freq (int): 设置的时钟频率 (仅当 data_type==SET_FREQUENCY 时有效)
            fbin (str): 发送的包内容 (仅当 data_type==NORMAL_FLIT 时有效)
            recv (bool): 是否接受 Darwin3 的返回包
            recv_run_flit_file (str): 保存返回包的名称
            debug (bool): 调试标记
        Returns:
            None
        """
        trans = Transmitter()
        trans.connect_lwip((self.ip, port))

        match data_type:
            case darwin3_device.FlitType.CHIP_RESET:
                trans.socket_inst.sendall(struct.pack('II', 0x0000,data_type))
                print("===<2>=== reset succeed")
            case darwin3_device.FlitType.SET_FREQUENCY:
                trans.socket_inst.sendall(struct.pack('II', 333,data_type))
                print("===<2>=== set frequency succeed")
            case _ :
                trans.send_flit_bin(flit_bin, data_type)

        if recv: fout=trans.recv(recv_run_flit_file)
        else: fout=BytesIO()
        trans.close()

        return fout

    def _gen_spike_input_dwnc(
        self,
        neuron_spike_list: list,
    ) -> list:
        """
        input_neuron.json && length of spike_neurons (list) => spikes.dwnc
        跟据spikes.dwnc以及config文件中提到的神经元，生成对应的run_input.dwnc文件
        Args:
            neuron_spike_list (list): 输入的神经元脉冲序列
        Returns:
            dwnc list
        """
        dwnc_list=[(PKG_CMD,0,1)] # open time step
        for _i in range(0, len(neuron_spike_list)):
            dwnc_list.append((PKG_CMD,0b011000,0)) # step 1
            cur_spike_neuron_list = neuron_spike_list[_i]
            for spike_neuron in cur_spike_neuron_list:
                neuron_info = self.model.input_neuron[str(spike_neuron)]
                if len(neuron_info) > 0:
                    neuron_type = neuron_info[0]
                    targets_list = neuron_info[-1]
                    if neuron_type == 0:
                        neu_idx = neuron_info[1]
                    elif neuron_type == 1:
                        neu_idx = 0x0
                    for target in targets_list:
                        dwnc_list.append((PKG_SPIKE,target[0],target[1],neu_idx,target[2]))
            # dwnc_list.append((PKG_CMD,0b011000,0)) # step 1

        dwnc_list.append((PKG_CMD,0,0)) # turn off

        return dwnc_list

    def _excute_dwnc_command(self,dwnc_list,direction,type,saving_name='',recv=True,saving_recv=False) -> list:
        if isinstance(dwnc_list,CommandList):
            bin_io_rslt=dwnc_list.encode()
        else:
            bin_io_rslt=encode(dwnc_list,direction)
        # send
        # Path.write_bytes(Path(self._cache_path/'beagle_run_flits_in.bin'),bin_io_rslt)
        rslt = self._transmit_flit(port=self.port[0], 
                            data_type=type,
                            flit_bin=bin_io_rslt,
                            recv=recv,
                            recv_run_flit_file=None if not saving_recv else self._cache_path / f"recv_{saving_name}.txt")
        max_tik_index,rslt = decode(rslt)
        return max_tik_index,rslt
        
    def clear_neurons_states(self, ISC=False, LSC=False, clear=True, dwnc_file="clear_states"):
        """
        清理 darwin3 芯片内部神经拟态核心的状态量
        Args:
            ISC   (bool): inference status clear,
                          推理状态中电流清零, 阈值和振荡电位复位, 1 有效
                          相关配置寄存器: dedr_vth_keep, dedr_vth_gset, 
                          global_vth, dedr_res_keep, global_res
            LSC   (bool): learn status clear, 学习状态清零, 1 有效
            clear (bool): 权重和清零, 膜电位复位, 1 有效
                          相关配置寄存器:vt_rest
                          
            dwnc_file (str): 生成的配置文件名称
        Returns:
            None
        """
        # 根据需要重置的内容生成指令
        if CommandList.global_list.get('cls') is None: 
            west_dwnc_list=CommandList(entry=WEST)
            east_dwnc_list=CommandList(entry=EAST)

            west_dwnc_list.append((PKG_CMD,0,1))
            east_dwnc_list.append((PKG_CMD,0,1))

            for _x,_y in self.model.used_neuron_cores.keys():
                if _x <= 15: west_dwnc_list.append((PKG_WRITE,_x,_y,0x04,0b111)) # 清空
                else:        east_dwnc_list.append((PKG_WRITE,_x,_y,0x04,0b111))

            west_dwnc_list.extend(self.model.clear_is_west)
            east_dwnc_list.extend(self.model.clear_is_east)
            
            for key,value in self.model.delay_neuron.items():
                coord = eval(key)
                if coord[0] <= 15:
                    west_dwnc_list.append((PKG_WRITE,coord[0],coord[1],0x00800+value[0], value[1]))
                    west_dwnc_list.append((PKG_WRITE,coord[0],coord[1],0x00800+value[2], value[3]))
                else:
                    east_dwnc_list.append((PKG_WRITE,coord[0],coord[1],0x00800+value[0], value[1]))
                    east_dwnc_list.append((PKG_WRITE,coord[0],coord[1],0x00800+value[2], value[3]))

            west_dwnc_list.append((PKG_CMD,0,0))
            east_dwnc_list.append((PKG_CMD,0,0))

            CommandList.global_list['cls']=(west_dwnc_list,east_dwnc_list)
        else:
            west_dwnc_list,east_dwnc_list=CommandList.global_list['cls']

        # send
        self._transmit_flit(port=self.port[0], 
            data_type=FlitType.CLEAR_STATE,
            flit_bin=west_dwnc_list.encode(),
            recv=False,
            recv_run_flit_file=None)
        return

    def _gen_deploy_flitin(self):
        """
        *-*-config.dwnc => deploy_input.dwnc
        Args:
            deploy_input_dwnc_file (str): 生成的 dwnc 文件的名称
        Returns:
            None
        """
        # 东西向传输
        west_dwnc_list=CommandList(entry=WEST)
        east_dwnc_list=CommandList(entry=EAST)

        for _cmd_list in self.model.used_neuron_cores.values():
            if _cmd_list.entry==WEST: west_dwnc_list.extend(_cmd_list)
            if _cmd_list.entry==EAST: east_dwnc_list.extend(_cmd_list)

        # 加入开启/停止tik控制对 => 代表配置结束
        west_dwnc_list.append((PKG_CMD,0,1))
        west_dwnc_list.append((PKG_CMD,0,0))

        east_dwnc_list.append((PKG_CMD,0,1))
        east_dwnc_list.append((PKG_CMD,0,0))

        # 设置hardware_step_size
        west_dwnc_list.append((PKG_CMD,0b100000,self.hardware_step_size))
        east_dwnc_list.append((PKG_CMD,0b100000,self.hardware_step_size))

        # 清除神经元推理状态和权重和
        for _x,_y in self.model.used_neuron_cores.keys():
            if _x <= 15:
                west_dwnc_list.append((PKG_WRITE,_x,_y,0x04,0x5)) # 清空
                west_dwnc_list.append((PKG_WRITE,_x,_y,0x15,0x1)) # 使能
            else:
                east_dwnc_list.append((PKG_WRITE,_x,_y,0x04,0x5))
                east_dwnc_list.append((PKG_WRITE,_x,_y,0x15,0x1))

        return west_dwnc_list,east_dwnc_list

    def deploy_config(self):
        """
        在部署芯片上部署并使能相关核心, 同时清除神经元的相关状态
        Args:
            None
        Returns:
            None
        """
        dwnc_west,dwnc_east=self._gen_deploy_flitin()
        self._excute_dwnc_command(dwnc_west,WEST,'deploy',type=FlitType.NORMAL_FLIT,recv=False)
        # self._excute_dwnc_command(dwnc_east,EAST,'deploy',recv=False)

    def run_darwin3_withoutfile(self,spike_neurons):
        '''
        obselete api
        '''
        return self.run_darwin3_with_spikes(spike_neurons)

    def run_darwin3_withfile(self,spike_neurons):
        '''
        obselete api
        '''
        return self.run_darwin3_with_spikes(spike_neurons)

    def run_darwin3_with_spikes(self, spike_list: list,saving_input=False,saving_recv=False,print_log=False):
        """
        接收应用给的 spike_list 作为输入，运行 len(spike_list) 个时间步
        Args:
            spike_list (list): sequence, 本次应用输入给硬件的脉冲数据, 
                                  序列长度与时间步数量一致，没有脉冲的时间步给空值

            [
                [0,1,2], # neuron 0,1,2 fired at tick=0
                [0,1], # neuron 0,1 fired at tick=1
            ]
        Returns:
            result (list): 本次运行结束时硬件返回给应用的脉冲
        """
        # 生成spike的dwnc
        dwnc_list=self._gen_spike_input_dwnc(spike_list)
        if saving_input:
            (self._cache_path / 'run_input_dwnc.txt').write_text('\n'.join(dwnc_list))

        max_tik_index,rslt=self._excute_dwnc_command(
            dwnc_list,
            WEST,
            FlitType.NORMAL_FLIT,
            'run_flitin',
            True,
            saving_recv)

        return SpikeResult.parse_spike(self.model.output_neuron_info_jsons,rslt,max_tik_index+1)
    
    def run_with_torch_tensor(self,spike_tensor,output_layer_name,output_shape:tuple,extra_time_steps=0,saving_input=False,saving_recv=False,print_log=False):
        """
        接收应用给的 PyTorch Tensor
        Args:
            spike_tensor: in [t x], 注意batch_size必须为1
        Returns:
            result tensor: in [t x] 本次运行结束时硬件返回给应用的脉冲
        """

        t,_=spike_tensor.shape
        spike_list=[]
        for _i in range(t):
            spike_list.append(torch.where(spike_tensor[_i]==1)[0].tolist())
        
        for _ in range(extra_time_steps): spike_list.append([])


        # 生成spike的dwnc
        dwnc_list=self._gen_spike_input_dwnc(spike_list)
        if saving_input:
            (self._cache_path / 'run_input_dwnc.txt').write_text('\n'.join(dwnc_list))

        max_tik_index,rslt=self._excute_dwnc_command(
            dwnc_list,
            WEST,
            FlitType.NORMAL_FLIT,
            'run_flitin',
            True,
            saving_recv)

        rslt=SpikeResult.parse_spike_single_layer(self.model.output_neuron_info_jsons[output_layer_name],rslt,max_tik_index+1)
        
        target_t,target_x=output_shape
        output_spike=torch.zeros(target_t,target_x)
        rslt=rslt[-target_t:]
        for _t,_spike_ids in enumerate(rslt):
            output_spike[_t,torch.tensor(_spike_ids)]=1
        
        return output_spike

    def dump_memory(self,dump_request:list[tuple],log=False,saving_intermediate_dir: Path | None =None) -> tuple[list]:
        '''
        dump the memory of the specific neuromorphic core.
        ---
        @dump_request: 
        
            list of tuple:(

                nc_position: nc core coordinate, (x,y)

                length : words to be read, int

                offset : words offset, int

                inverse: read in reverse order, bool

            )

        @log: log to console

        @saving_dwnc_path: saving intermediate files
        '''
        raise NotImplementedError
        # construct dwnc list
        east_cmds=['0 cmd 0xc0000001\n']
        west_cmds=['0 cmd 0xc0000001\n']

        # x,y=nc_position
        for (_x,_y), _length, _offset, _inverse in dump_request:
            if _inverse:
                _addr_iter=range(_offset,_offset-_length,-1)
            else:
                _addr_iter=range(_offset,_offset+_length)

            for _2_addr in _addr_iter:
                cmd = f"0 read {_x} {_y} {hex(_2_addr)} 1\n"
                if _x>=15:
                    east_cmds.append(cmd)
                else:
                    west_cmds.append(cmd)

        east_cmds.append('0 cmd 0xc0000000\n')
        west_cmds.append('0 cmd 0xc0000000\n')
        
        rslt_west=None
        rslt_east=None
        if len(east_cmds)>2:
            with open('get_nc_denrites_east.dwnc','w') as f:
                f.writelines(east_cmds)
            self.__flit_gen_east__(type="debug", input_file='get_nc_denrites_east.dwnc', output_file='get_nc_denrites_east_flitin')
            self.__transmit_flit__(port=self.port[1], data_type=0x8000, 
                                   fbin=self._cache_path+'get_nc_denrites_east_flitin.bin', 
                                   recv=True, recv_run_flit_file="get_nc_denrites_east_recv",
                                   debug=True)
            rslt_east=parse_flit(recv_run_flit_file='get_nc_denrites_east_recv', log=log)

        if len(west_cmds)>2:
            if saving_intermediate_dir is not None:
                with open(saving_intermediate_dir/'get_nc_dendrites_west.dwnc','w') as f:
                    f.writelines(west_cmds)

            rslt_west= self._excute_dwnc_command(
                west_cmds,
                saving_intermediate_dir,
                'get_nc_dendrites_west_filtin',
                True if saving_intermediate_dir is not None else False,
                True if saving_intermediate_dir is not None else False,
                parser_log=log)
            
        return rslt_east,rslt_west
    
    def get_neuron_inference_status(self, nc_position:tuple,length:int,offset=0,log=False,saving_path: Path | None=None) -> tuple[list]:
        """
        获取推理存储器内容
        ---
        Args:
            nc_position: 神经元位置
            length: 读取的字数
            offset (int): 用户指定的地址偏移
            log: 是否输出到控制台
            saving_path: saved path of intermediate results (dwnc, flit in, flit out, etc.)
        Returns: 
            rslt_east,rslt_west
        """
        return NotImplementedError
        return self.dump_memory([(nc_position,length,0x0FFFF-offset,True)],log,saving_path)
    
    def get_dendrites_memory(self, nc_position:tuple,length:int,offset=0,log=False,saving_path: Path | None=None) -> tuple[list]:
        """
        获取树突存储器内容
        ---
        Args:
            nc_position: 神经元位置
            length: 读取的字数
            offset (int): 用户指定的地址偏移
            log: 是否输出到控制台
            saving_path: saved path of intermediate results (dwnc, flit in, flit out, etc.)
        Returns: 
            rslt_east,rslt_west
        """
        raise NotImplementedError
        return self.dump_memory([(nc_position,length,0x10000+offset,False)],log,saving_path)
    
    def get_learn_memory(self, nc_position:tuple,length:int,offset=0, log=False,saving_path: Path | None=None) -> tuple[list]:
        """
        获取学习状态存储器内容
        ---
        Args:
            nc_position: 神经元位置
            length: 读取的字数
            offset (int): 用户指定的地址偏移
            log: 是否输出到控制台
            saving_path: saved path of intermediate results (dwnc, flit in, flit out, etc.)
        Returns: 
            rslt_east,rslt_west
        """
        raise NotImplementedError
        return self.dump_memory([(nc_position,length,0x1DFFF-offset,True)],log,saving_path)